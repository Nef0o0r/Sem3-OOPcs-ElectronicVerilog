Исходный код программы:

module pwm_led
#(parameter  LED_COUNT = 6, parameter COOLDOWN = 21) // для симуляции COOLDOWN = 3, для запуска 21
(
    input clk,
    input  up,
    input down,
    output [LED_COUNT-1:0] led  
);

initial
begin
    counter <= 0;
    cooldown <= 0;
    shift <= 0;
end

reg [2:0] shift;
reg [COOLDOWN-1:0] cooldown;
reg [2:0] counter;

always @(posedge clk)
begin
    if (counter < LED_COUNT-1)
        counter <= counter + 1'b1;
    else
        counter <= 0;
end

always @(posedge clk)
begin
    if (!cooldown)
    begin
        if (!up)
        begin
            cooldown <= 2**COOLDOWN-1;
            if (shift < LED_COUNT-1)
                shift <= shift + 1'b1;
            else
                shift <= 0;
    end
    else if (!down)
    begin
        cooldown <= 2**COOLDOWN-1;
        if (shift > 0)
            shift <= shift - 1'b1;
        else
            shift <= LED_COUNT-1;
        end
    end
    else
        cooldown <= cooldown - 1'b1;
end

genvar i;
generate
        for (i = 0; i < LED_COUNT; i = i + 1)
        begin : led_block  
            assign led[i] = counter > (i + shift) % LED_COUNT;
        end
endgenerate

endmodule



Исходный код тестбенча:

`timescale 1ns / 1ns

module pwm_led_tb();

reg clk;  // Тактовый сигнал
reg up;
reg down;
wire [5:0] led;  // Светодиоды

// Экземпляр тестируемого модуля
pwm_led uut(.clk(clk), .up(up), .down(down), .led(led));

// Генерация тактового сигнала с периодом 10 нс (частота 100 МГц)
initial begin
    clk = 0;
    forever #(5) clk = ~clk;  // Период 10 нс
end

initial
begin
    up <= 1;
    down <= 1;
    #20 up <= 0;
    #180 up <= 1;
    #200 down <= 0;
    #200 down <= 1;
end


// Завершение симуляции через 1000 нс
initial begin
    #1000 $finish;
end

// Сохранение результата симуляции в файл VCD для анализа
initial begin
    $dumpfile("pwm_led_out.vcd");
    $dumpvars(0, pwm_led_tb);
end

endmodule
