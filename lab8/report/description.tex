{\bfseries Цель работы} 

Освоение механизмов работы конструкторов и деструкторов в языке программирования C\#.

{\bfseries Используемые аппаратные и программные средства}
\begin{itemize}
    \item Лабораторная работа выполнена на операционной системе Arch Linux;
    \item В качестве среды разработки (IDE) используется NeoVim;
    \item Используемый компилятор --- dotnet;
    \item Версия SDK --- 8.0;
    \item Отчет написан на LaTex.
\end{itemize}


\chapter{Ход работы}
    
В качестве исходных данных для выполнения лабораторной работы выступает программный код, описывающий банковское приложеные, осуществляющее транзакции между аккаунтами пользователей. В исходном коде описаны следующие программные сущности:

\begin{enumerate}
    \item Класс CreateAccount, содержащий точку входа программы и предназначенный для инициализации пользовательских аккаунтов и непосредственно выполнения денежных операций с последующим выводом информации об осуществленных транзакциях и информации об аккаунтах;
    \item Класс BankAccount описывает пользовательский аккаунт и логику осуществления банковских операций. Класс содержит конструкторы, позволяющие инициализировать аккаунты пользователей при разных начальных данных (например по балансу, по типу и тп.), а также геттеры, возвращающие различную информацию об аккаунте;
    \item Класс BankTransaction описывает банковскую транзакцию и позволяет оперировать такими данныме о денежных переводах, как дата и время совершения операции и номинальность операции.
\end{enumerate}

\newpage

Полный исходный код предствален в приложении 1. 
Листинг программы отражен на следующей иллюстрации:
\pic[H][70mm]{1}{Запуск исходной программы}

	\section{Создание деструктора}

    В ходе выполнения упражнения в класс BankTransaction был добавлен деструктор (финализатор), создающий/открывающий файл Transactions.Dat и записывающий в неого дату и время совершения транзакции.
    Исходный код деструктора:

\begin{lstlisting}[style=CSharpStyle]
~BankTransaction()
{
    StreamWriter swFile = File.AppendText("Transactions.Dat");
    swFile.WriteLine("Date/Time: {0}\tAmount: {1}", when, amount);
    swFile.Close();
    GC.SuppressFinalize(this);
}
\end{lstlisting} 

    Стоит учитывать особенности работы сборщика мусора в C\# начиная с версии .Net 5.0 из-за которых при завершении программы деструкторы не вызываются. Освобождение памяти происходит позже, когда система сочтет это необходимым.
    Таким образом для вызова деструкторов необходимо явно вызвать сборку мусора, но этого будет мало для текущей реализации. 

    Так как в ней в классе BankAccount используется Queue, сборщик мусора не будет освобождать память экземпляров этого класса до тех пор, пока очередь содержит действительные объекты, поэтому Queue также необходимо освободить вручную.

    Для ручного освобождения очереди в классе BankAccount был описан метод Dispose (паттерн в C\#, предназначенный для ручного освобождения памяти; <<ручной деструктор>>).
    После вызова метода Dispose() экземпляр класса является недействительным (очищенным).

    Реализация метода Dispose:

\begin{lstlisting}[style=CSharpStyle]
class BankAccount : IDisposable
{
    ...
    public void Dispose()
    {
        tranQueue.Clear();
    }
}
\end{lstlisting}  

    Ручной вызов сборщика мусора в методе Main:

\begin{lstlisting}[style=CSharpStyle]
class CreateAccount
{
    static void Main() 
    {
        BankAccount acc1;

        acc1 = new BankAccount();
        acc1.Deposit(200);
        acc1.Withdraw(100);
        Write(acc1);

        acc1.Dispose();

        GC.Collect();
        GC.WaitForPendingFinalizers();
    }
    ...
}
\end{lstlisting}  

    Полный исходный код программы представлен в приложении 2.
    В результате работы программы в директории проекта будет создан файл Transactions.Dat со следующим содержимым:
\begingroup
\fontsize{12pt}{12pt}\selectfont
\linespread{1.5}
\begin{verbatim}
Date/Time: 09/26/2024 16:10:31	Amount: -100
Date/Time: 09/26/2024 16:10:31	Amount: 200
\end{verbatim}  
\endgroup
    В исходной реализации программы экземпляры транзакций хранятся в очереди, которая является полем класса BankAccount.
    По этой причине деструкторы (финализаторы) экземпляров транзакции не вызываются до тех пор, пока они не были выведены из очереди.
    Так как экземпляры транзакций должны храниться в очереди в течении всего времени существования объекта класса BankAccount для корректного вывода информации о транзакциях, деструкторы транзакций будут выполнены при уничтожении объекта класса BankAccount, из-за чего время транзакций, выведенное в файл, будет соответствовать времени уничтожения экземпляра BankAccount, а не времени совершения транзакции.
    Таким образом, с точки зрения выполнения поставленных задач данная реализация некорректна.
    
    Для исправления описанного бага содержимое деструктора BankTransaction должно быть перенесено в его конструктор.


\newpage
{\bfseries {ВЫВОД}}

В результате выполнения лабораторной работы были закреплены на практике теоретические знания о конструкторах и деструкторах в языке программирования C\#.

Продуктом лабораторной работы является реализованая программа, описывающая банковское приложение, осуществляющее транзакции между аккаунтами пользователей.

В ходе выполнения лабораторной работы были изучены особенности сборки мусора в современных версиях .Net (начиная с 5.0), которые заключаются в отсутствии автоматического освобождения памяти (в том числе вызовов деструкторов) сборщиком мусора по завершении выполнения программы.
Освобождение памяти происходит позже, когда система сочтет это необходимым. 
Таким образом для ручного освобождения памяти в программе были использованы явный вызов сборщика мусора и патерн Dispose.

Также была выявлена особенность освобождения памяти для экземпляров класса Queue. 
Память выделенная для них автоматически освобождается только тогда, когда очередь не содержит действительных объектов.
