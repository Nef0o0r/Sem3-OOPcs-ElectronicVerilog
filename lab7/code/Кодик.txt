Упражнение 1:
using System;
using System.Collections.Specialized;
using System.Runtime.Intrinsics.X86;
enum AccountType
{
    Checking,
    Deposit
}
class BankAccount
{
    private long accNo;
    private decimal accBal;
    private AccountType accType;

    private static long nextNumber = 123;

    public void Populate(decimal balance)
    {
        accNo = NextNumber();
        accBal = balance;
        accType = AccountType.Checking;
    }

    public bool Withdraw(decimal amount)
    {
        bool sufficientFunds = accBal >= amount;
        if (sufficientFunds)
        {
            accBal -= amount;
        }
        return sufficientFunds;
    }
    public decimal Deposit(decimal amount)
    {
        accBal += amount;
        return accBal;
    }
    public void TransferFrom(BankAccount accForm, decimal amount)
    {
        if (accForm.Withdraw(amount) == true)
        {
            Deposit(amount);
        }
    }
    //b1.Transfer(b2, 100)
    public long Number()
    {
        return accNo;
    }

    public decimal Balance()
    {
        return accBal;
    }

    public string Type()
    {
        return accType.ToString();
    }

    private static long NextNumber()
    {
        return nextNumber++;
    }
    public class Test
    {
        public static void Main()
        {
            BankAccount b1 = new BankAccount();
            BankAccount b2 = new BankAccount();
            b1.Populate(100);
            b2.Populate(100);
            Console.WriteLine("Счета до операций:");
            Console.WriteLine("b1 - Тип:{0}, Номер: {1}, Баланс: {2}", b1.Type(), b1.Number(), b1.Balance());
            Console.WriteLine("b2 - Тип:{0}, Номер: {1}, Баланс: {2}", b2.Type(), b2.Number(), b2.Balance());
            b1.TransferFrom(b2, 10);
            Console.WriteLine("Счета после операций:");
            Console.WriteLine("b1 - Тип:{0}, Номер: {1}, Баланс: {2}", b1.Type(), b1.Number(), b1.Balance());
            Console.WriteLine("b2 - Тип:{0}, Номер: {1}, Баланс: {2}", b2.Type(), b2.Number(), b2.Balance());


        }
    }
}
Упражнение 2:
namespace Utils
{
    using System;

    class Utils
    {

        //
        // Return the larger of two integer values
        //

        public static int Greater(int a, int b)
        {
            if (a > b)
                return a;
            else
                return b;

            // Alternative version - more terse
            // return (a>b) > (a) : (b);
        }

        //
        // Swap two integers, passed by reference
        //

        public static void Swap(ref int a, ref int b)
        {
            int temp;
            temp = a;
            a = b;
            b = temp;
        }

        //
        // Calculate factorial
        // and return the result as an out parameter
        //

        public static bool Factorial(int n, out int answer)
        {
            int k;        // loop counter
            int f;        // working value
            bool ok = true; // true if ok, false if not

            // Check the input value

            if (n < 0)
                ok = false;

            // Calculate the factorial value as the
            // product of all the numbers from 2 to n

            try
            {
                checked
                {
                    f = 1;
                    for (k = 2; k <= n; ++k)
                    {
                        f = f * k;
                    }

                    // Here is a terse alternative
                    // for (f=1,k=2;k<=n;++k)
                    //     f*=k;

                }
            }
            catch (Exception)
            {
                // If something goes wrong in the calculation,
                // catch it here. All exceptions
                // are handled the same way: set the result to
                // to zero and return false.

                f = 0;
                ok = false;
            }

            // assign result value                
            answer = f;

            // return to caller
            return ok;
        }

        //
        // Another way to solve the factorial problem, this time
        // as a recursive function
        //

        public static bool RecursiveFactorial(int n, out int f)
        {
            bool ok = true;

            // Trap negative inputs
            if (n < 0)
            {
                f = 0;
                ok = false;
            }

            if (n <= 1)
                f = 1;
            else
            {
                try
                {
                    int pf;
                    checked
                    {
                        ok = RecursiveFactorial(n - 1, out pf);
                        f = n * pf;
                    }
                }
                catch (Exception)
                {
                    // Something went wrong. Set error
                    // flag and return zero.
                    f = 0;
                    ok = false;
                }

            }

            return ok;
        }
        public static void Reverse(ref string s)
        {
            string sRev = "";
            for (int i = s.Length; i > 0; i--)
            {
                sRev += s[i - 1];
            }
            s = sRev;
        }
        public class Test
        {
            public static void Main()
            {
                string message;
                Console.WriteLine("До");
                message = Console.ReadLine();
                Console.WriteLine(message);
                Utils.Reverse(ref message);
                Console.WriteLine("После");
                Console.WriteLine(message);
            }
        }
    }
}

Упражнение 3:
using System;
using System.IO;
public class CopyFileUpper
{
    public static void Main()
    {
        try
        {
            string sFrom, sTo;
            StreamReader srFrom;
            StreamWriter swTo;
            Console.WriteLine("Введите имя входного файла");
            sFrom = Console.ReadLine();
            Console.WriteLine("Введите имя выходного файла");
            sTo = Console.ReadLine();
            srFrom = new StreamReader(sFrom);
            swTo = new StreamWriter(sTo);
            while (srFrom.Peek() != -1)
            {
                string sBuffer = srFrom.ReadLine();
                swTo.WriteLine(sBuffer.ToUpper());
            }
            srFrom.Close();
            swTo.Close();
        }
        catch (FileNotFoundException e)
        {
            Console.WriteLine("Файл не существует");
        }
        catch (Exception e)
        {
            Console.WriteLine("Произошла ошибка");
        }
    }
}

Упражнение 4:
namespace Utils
{
    using System;

    class Utils
    {

        //
        // Return the larger of two integer values
        //

        public static int Greater(int a, int b)
        {
            if (a > b)
                return a;
            else
                return b;

            // Alternative version - more terse
            // return (a>b) > (a) : (b);
        }

        //
        // Swap two integers, passed by reference
        //

        public static void Swap(ref int a, ref int b)
        {
            int temp;
            temp = a;
            a = b;
            b = temp;
        }

        //
        // Calculate factorial
        // and return the result as an out parameter
        //

        public static bool Factorial(int n, out int answer)
        {
            int k;        // loop counter
            int f;        // working value
            bool ok = true; // true if ok, false if not

            // Check the input value

            if (n < 0)
                ok = false;

            // Calculate the factorial value as the
            // product of all the numbers from 2 to n

            try
            {
                checked
                {
                    f = 1;
                    for (k = 2; k <= n; ++k)
                    {
                        f = f * k;
                    }

                    // Here is a terse alternative
                    // for (f=1,k=2;k<=n;++k)
                    //     f*=k;

                }
            }
            catch (Exception)
            {
                // If something goes wrong in the calculation,
                // catch it here. All exceptions
                // are handled the same way: set the result to
                // to zero and return false.

                f = 0;
                ok = false;
            }

            // assign result value                
            answer = f;

            // return to caller
            return ok;
        }

        //
        // Another way to solve the factorial problem, this time
        // as a recursive function
        //

        public static bool RecursiveFactorial(int n, out int f)
        {
            bool ok = true;

            // Trap negative inputs
            if (n < 0)
            {
                f = 0;
                ok = false;
            }

            if (n <= 1)
                f = 1;
            else
            {
                try
                {
                    int pf;
                    checked
                    {
                        ok = RecursiveFactorial(n - 1, out pf);
                        f = n * pf;
                    }
                }
                catch (Exception)
                {
                    // Something went wrong. Set error
                    // flag and return zero.
                    f = 0;
                    ok = false;
                }

            }

            return ok;
        }
        public static bool IsItFormattable(object x)
        {
            return x is IFormattable;
        }
    }
    public class Test
    {
        public static void Main()
        {
            int i = 0;
            ulong ul = 0;
            string s = "Test";
            Console.WriteLine(Utils.IsItFormattable(i));
            Console.WriteLine(Utils.IsItFormattable(ul));
            Console.WriteLine(Utils.IsItFormattable(s));
        }
    }
}

Упражнение 5:
namespace Utils
{
    using System;

    class Utils
    {
        public static bool IsItFormattable(object x)
        {
            // Use is to test if the object has the
            // IFormattable iterface

            if (x is IFormattable)
                return true;
            else
                return false;
        }

        //
        // Return the larger of two integer values
        //
        public static int Greater(int a, int b)
        {
            if (a > b)
                return a;
            else
                return b;

            // Alternative version - more terse
            // return (a>b) ? (a) : (b);
        }

        //
        // Swap two integers, passed by reference
        //

        public static void Swap(ref int a, ref int b)
        {
            int temp;
            temp = a;
            a = b;
            b = temp;
        }

        //
        // Calculate factorial
        // and return the result as an out parameter
        //

        public static bool Factorial(int n, out int answer)
        {
            int k;        // loop counter
            int f;        // working value
            bool ok = true; // true if ok, false if not

            // Check the input value

            if (n < 0)
                ok = false;

            // Calculate the factorial value as the
            // product of all the numbers from 2 to n

            try
            {
                checked
                {
                    f = 1;
                    for (k = 2; k <= n; ++k)
                    {
                        f = f * k;
                    }

                    // Here is a terse alternative
                    // for (f=1,k=2;k<=n;++k)
                    //     f*=k;

                }
            }
            catch (Exception)
            {
                // If something goes wrong in the calculation,
                // catch it here. All exceptions
                // are handled the same way: set the result to
                // to zero and return false.

                f = 0;
                ok = false;
            }

            // assign result value                
            answer = f;

            // return to caller
            return ok;
        }

        //
        // Another way to solve the factorial problem, this time
        // as a recursive function
        //

        public static bool RecursiveFactorial(int n, out int f)
        {
            bool ok = true;

            // Trap negative inputs
            if (n < 0)
            {
                f = 0;
                ok = false;
            }

            if (n <= 1)
                f = 1;
            else
            {
                try
                {
                    int pf;
                    checked
                    {
                        ok = RecursiveFactorial(n - 1, out pf);
                        f = n * pf;
                    }
                }
                catch (Exception)
                {
                    // Something went wrong. Set error
                    // flag and return zero.
                    f = 0;
                    ok = false;
                }

            }
            return ok;
        }
        interface IPrintable
        {
            void Print();
        }
        class Coordinate : IPrintable
        {
            private double x;
            private double y;

            public Coordinate()
            {
                x = 0.0;
                y = 0.0;
            }

            public Coordinate(double px, double py)
            {
                x = px;
                y = py;
            }

            public void Print()
            {
                Console.WriteLine("({0},{1})", x, y);
            }
        }
        public static void Display(object item)
        {
            IPrintable ip;
            ip = item as IPrintable;
            if (ip != null)
            {
                ip.Print();
            }
            else
            {
                Console.WriteLine(item.ToString());
            }

        }
        public class Test
        {
            public static void Main()
            {
                int num = 65;
                string msg = "A String";
                Coordinate c = new Coordinate(21.0, 68.0);
                Utils.Display(num);
                Utils.Display(msg);
                Utils.Display(c);

            }
        }
    }
}

